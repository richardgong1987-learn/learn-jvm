# 垃圾收回机制

## 是否可回收算法

### 引用计数法

弊端: 无法收回循环引用的对象

### 可达性分析算法 java使用的

想像葡萄和树根的关系

工具:Memory Analyzer(MAT) 专业的heap分析工具,找到根对象,内存泄漏点

注意这个工具需要用jmap配合使用. 需要先用jmap抓取内存,然后再用MAT来分析



### 四种引用

#### 强引用

常见的就是用new出来的

GC root直接引用的

#### 软引用 

 间接引用

`Object obj = new Object();`
`SoftReference<Object> sf = new SoftReference<Object>(obj);`
`obj = null;`
`sf.get();//有时候会返回null`

`可以创建软引用`

使用场景：在内存足够的情况下进行缓存，提升速度

#### 弱引用

也是间接引用

Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null

使用场景：1. ThreadLocalMap防止内存泄漏  2. 监控对象是否将要被回收



它和软引用的区别在于:

- 软引用如果一个对象只具有软引用，而当前虚拟机堆内存空间足够，那么垃圾回收器就不会回收它，反之就会回收这些软引用指向的对象。

弱引用与软引用的区别在于，垃圾回收器一旦发现某块内存上只有弱引用（一定请注意只有弱引用，没强引用），不管当前内存空间是否足够，那么都会回收这块内存。



#### 虚引用

 ReferenceQueue<String> queue = new ReferenceQueue<String>();
        PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
        System.out.println(pr.get());//永远都是null

虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

使用场景:主要用于监测对象是否已经从内存中删除

如:NIO的ByteBuffer对象,如果被回收了,那么直接内存不能直接回收,就得放到引用列队中进行手动收回



## 垃圾回收算法

### 标记清除算法

标记<-->清除

- 优点:速度快

- 缺点: 会有很多内存碎片

### 标记整理算法

- 优点:无内存碎片

- 缺点:速度较慢,实现复杂较高



### 复制算法

- 优点:无碎片

- 缺点:需要双倍内存空间





## 分代垃圾回收

### 新生代

想像成垃圾场

####    伊甸园

人类始祖亚当夏娃始创人类的地方

这个内存区域会保在所有对象初始创建时存在

####   幸存区from

在幸存区to交换位置后使用

####   幸存区to

这个内存区域都是存在"复制算法"幸存的内存

并且,寿命会加1



总结:幸存区都是给复制算法用的

### 老年代

默认在幸存区被几次(不一定是15次)都没被回收时,可能会被放到老年代中

-   长时间需要使用的对象,放在老年代中

- 执行频率比较低



1. **对象首先分配到伊甸园区域**
2. **新生代空间不足时,触发minor GC,伊甸园和from存活的对象使用复制算法,复制到to中.存活的对象年龄加1 ,并且 from和to交换空间**
3. **Minor GC会引发stop the world,暂时其它用户的线程.玍垃圾回收结束,用户线程才会恢复运行**
4. **当对象寿命超过阀值时,会晋升到老年代,是大寿命是15**(4bit)
5. **当老年代空间不足,会先尝试触发minor GC,如果之后空间仍不足,那么触发full GC,stop the world的时间更长**

#### 

## 垃圾回收器

###   串行

1. 单线程
2. 堆内存较小,适合个人电脑

###   吞吐量优先

1.  多线程
2. 堆内存较大,多核cpu



###   响应时间优先

1.  多线程
2. 堆内存较大,多核cpu