# 内存模型

注意,内存结构和内存模型不是一回事



内存模型是用来定义一套在多线程读写共享数据时(成员变量,数组)时,

对数据的可见性,有序性,和原子性的规则和保障



## 原子性

解决办法

## 可见性

出不退的while循环

 可以通过volatile来解决放到高速缓存

用volatile修饰过的变量,表示在读取的变量都

会到内存读取,避免因为高速缓存造成的

无法退出的while



但注意:

Volatile 不能保存原子性

volatile适合场景主要是在一个人写,多个人读,是比较适合的



System.out.println可以破坏调整缓存机制的原因是因为

println是加了synchoninzed关键字.

Synchominzed关键是是会破坏高速缓存的



## 有序性

volatile可以禁止指令重排

有极少的情况会因为运行时优化,会进行指令重排 的问题

而用volatile可以禁止指令重排



### 3.3 有序性理解

多线程下指令重排,会出现问题



双重判断单例模式实现



也会有双重指令重排.

这种情况下,可以用volatile解决



### Happens-before规则



## CAS与原子类

### 乐观锁 

CAS, Compare and Swap乐观锁的思想

它不会线程堵塞

所以性能高

### 悲观锁

Synchronized 就是悲观锁的典型代表



### 原子操作类

Java.util.concurrent类





## synchronized优化

初始状态是轻量锁

- 轻量级锁

  synchronized初始是轻量锁

  轻量锁升级为重量锁就是叫:锁锁膨胀

  第二次加锁,可以叫锁重入

  

- 重量锁

  自动自旋重度状态:锁自旋

  如果自旋失败的话,就会陷入阻塞

- 偏向锁

  没有发生竞争,发生了锁重入

  偏向锁是在mark work写入的是自己的线程id

  这种其实就是没有锁.

  重偏向,表示多个没有竞争的偏向锁.

  从t1重新偏向了t2

- 其它优化

  - 减少上锁时间

  - 锁粗化

    多次循环进入同步代码块,不如同步代码块多次循环

  - 锁消除

  - 读写分离

  - 减少锁的粒度

     将一个锁拆分成多个锁,提高并发度,例如:

    - ConcurrentHashMap

    - LongAddrer
    - LinkedBlockingQueue 入队出队使用不同的锁

    

    

    

    

    

    

    



